- hosts: bastion
  vars:
    internet_type:  "{{ lookup('env','GI_INTERNET_ACCESS') }}"
    bas_ip:  "{{ lookup('env','GI_BASTION_IP') }}"
    bas_name:  "{{ lookup('env','GI_BASTION_NAME') }}"
    domain:  "{{ lookup('env','GI_DOMAIN') }}"
    ocp_release: "{{ lookup('env','GI_OCP_RELEASE') }}"
    install_gi:  "{{ lookup('env','GI_INSTALL_GI') }}"
    install_ldap:  "{{ lookup('env','GI_INSTALL_LDAP') }}"

  tasks:
    - name: Check configuration parameters
      fail: msg="Variable {{ item.name }} is not set"
      when: item.value == ""
      loop:
        - { name: "GI_INTERNET_ACCESS", value: "{{ internet_type }}" }
        - { name: "GI_BASTION_IP", value: "{{ bas_ip }}" }
        - { name: "GI_BASTION_NAME", value: "{{ bas_name }}" }
        - { name: "GI_DOMAIN", value: "{{ domain }}" }
        - { name: "GI_OCP_RELEASE", value: "{{ ocp_release }}" }
        - { name: "GI_INSTALL_GI", value: "{{ install_gi }}" }
        - { name: "GI_INSTALL_LDAP", value: "{{ install_ldap }}" }

    - name: Set parameters for air-gapped installation
      set_fact:
        archives_dir:  "{{ lookup('env','GI_ARCHIVES_DIR') }}"
        repo_user:  "{{ lookup('env','GI_REPO_USER') }}"
        repo_user_password:  "{{ lookup('env','GI_REPO_USER_PWD') }}"
      when: internet_type == 'A'

    - name: Check configuration parameters for air-gapped installation
      fail: msg="Variable {{ item.name }} is not set"
      when: internet_type == 'A' and item.value == ""
      loop:
        - { name: "GI_REPO_USER", value: "{{ repo_user }}" }
        - { name: "GI_REPO_USER_PWD", value: "{{ repo_user_password }}" }
        - { name: "GI_ARCHIVES_DIR", value: "{{ archives_dir }}" }

    - name: Upgrade system
      dnf:
        name: "*"
        state: latest
      register: dnf_updates
      when: internet_type != 'A'

    - name: Check for reboot hint.
      shell: LAST_KERNEL=$(rpm -q --last kernel | awk 'NR==1{sub(/kernel-/,""); print $1}'); CURRENT_KERNEL=$(uname -r); if [ $LAST_KERNEL != $CURRENT_KERNEL ]; then echo 'reboot'; else echo 'no'; fi
      ignore_errors: true
      register: reboot_hint

    - name: Create portable registry directories
      file:
        path: "{{ item.path }}"
        state: directory
      with_items:
        - { path: "/opt/registry/auth" }
        - { path: "/opt/registry/certs" }
        - { path: "/opt/registry/data" }
        - { path: "../ssl/csr" }
      when: internet_type == 'A'

    - name: Create certificate for portable registry
      shell:
        cmd: "openssl req -newkey rsa:4096 -nodes -sha256 -keyout /opt/registry/certs/bastion.repo.pem -x509 -days 365 -out /opt/registry/certs/bastion.repo.crt -subj \"/C=PL/ST=Miedzyrzecz/L=/O=Test /OU=Test/CN=registry.{{ domain }}\" -addext \"subjectAltName = DNS:registry.{{ domain }}\""
      when: internet_type == 'A'

    - name: Copy CA cert to Centos PKI
      copy:
        src: /opt/registry/certs/bastion.repo.crt
        dest: /etc/pki/ca-trust/source/anchors/
      when: internet_type == 'A'

    - name: Register self-signed CA
      shell:
        cmd: update-ca-trust extract
      when: internet_type == 'A'

    - name: Cleanup httpasswd file
      file:
        path: /opt/registry/auth/bastion.repo.htpasswd
        state: absent
      when: internet_type == 'A'

    - name: Create htpasswd file
      htpasswd:
        path: /opt/registry/auth/bastion.repo.htpasswd
        name: "{{ repo_user }}"
        crypt_scheme: bcrypt
        password: "{{ repo_user_password }}"
      when: internet_type == 'A'

    - name: Start firewall
      service:
        name: firewalld
        state: started
        enabled: yes

    - name: Open ports on bastion 1
      firewalld:
        port: "{{ item.port }}/{{ item.type }}"
        permanent: yes
        immediate: yes
        state: enabled
      with_items:
        - { port: "5000", type: "tcp" }
      when: internet_type == 'A'

    - name: Open ports on bastion 2
      firewalld:
        service: http
        permanent: yes
        state: enabled

    - name: Extract registry archive
      shell:
        cmd: "bsdtar -C ../gi-temp -xf {{ archives_dir }}/coreos-registry-{{ ocp_release }}.tar oc-registry.tar"
      when: internet_type == 'A'
      
    - name: Load image registry into local repository
      shell:
        cmd: podman load -i ../gi-temp/oc-registry.tar
      when: internet_type == 'A'

    - name: Remove oc-registry archive
      file:
        path: oc-registry.tar
        state: absent

    - meta: end_play

    - name: Find olm package
      find:
        paths: "{{ archives_dir }}"
        patterns: "olm-registry*tar"
      register: find_result
      when: internet_type == 'A'

    - name: Extract OLM archive
      unarchive:
        src: "{{ item.path }}"
        dest: ../gi-temp
      with_items: "{{ find_result.files }}"
      when: internet_type == 'A'

    - name: Find rook package
      find:
        paths: "{{ archives_dir }}"
        patterns: "rook-registry*tar"
      register: rook_archive
      when: internet_type == 'A'

    - name: Extract CoreOS registry for release {{ ocp_release }}
      unarchive:
        src: "../gi-temp/coreos-registry.tar"
        dest: /opt/registry
      when: internet_type == 'A'

    - name: Extract OLM registry for release {{ ocp_release }}
      unarchive:
        src: "../gi-temp/olm-registry.tar"
        dest: /opt/registry
      when: internet_type == 'A'

    - name: Load rook-ceph registry into local repository
      unarchive:
        src: "{{ item.path }}"
        dest: /opt/registry
      with_items: "{{ rook_archive.files }}"
      when: internet_type == 'A'

    - name: Check image repository existence
      shell:
        cmd: podman ps -a|grep bastion-registry|wc -l
      register: is_repo_available
      when: internet_type == 'A'

    - name: Remove existing bastion image registry container
      shell:
        cmd: "{{ item }}"
      loop:
        - podman stop bastion-registry
        - "podman container prune <<< 'Y'"
      when: internet_type == 'A' and is_repo_available.stdout == '1'

    - name: Setup image registry
      shell:
        cmd: 'podman run -d --name bastion-registry -p 5000:5000 -v /opt/registry/data:/var/lib/registry:z -v /opt/registry/auth:/auth:z -e "REGISTRY_AUTH=htpasswd" -e "REGISTRY_AUTH_HTPASSWD_REALM=Registry" -e "REGISTRY_HTTP_SECRET=ALongRandomSecretForRegistry" -e REGISTRY_AUTH_HTPASSWD_PATH=/auth/bastion.repo.htpasswd -v /opt/registry/certs:/certs:z -e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/bastion.repo.crt -e REGISTRY_HTTP_TLS_KEY=/certs/bastion.repo.pem docker.io/library/registry:2.6'
        chdir: /opt/registry
      when: internet_type == 'A'

    - name: Set SELINUX permissive access for NetworkManager
      shell:
        cmd: semanage permissive -a NetworkManager_t

    - name: Install ansible ldap reqs
      shell:
        cmd: ansible-galaxy collection install community.general
      when: install_ldap == 'Y' and internet_type != 'A'

    - debug:
        msg:
          - "Reboot required for updated kernel."
          - "Press ENTER to restart machine."
          - "Then re-login to bastion and read variables: '. variables.sh'"
          - "Continue installation by executing: 'ansible-playbook playbooks/02-setup-bastion-for-ocp-installation.yaml'"
      when: reboot_hint.stdout.find("reboot") != -1

    - pause:
        echo: no
      when: reboot_hint.stdout.find("reboot") != -1

    - name: Rebooting ...
      command: shutdown -r now "Reboot required for updated kernel"
      async: 0
      poll: 0
      ignore_errors: true
      when: reboot_hint.stdout.find("reboot") != -1

    - debug:
        msg:
          - "Execute 'ansible-playbook playbooks/02-setup-bastion-for-ocp-installation.yaml' to configure bastion for OCP installation"

